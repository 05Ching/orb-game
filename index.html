<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orb Catcher ‚Äî vibe-coded JS mini game</title>
  <style>
    :root {
      --bg: #0b1020;
      --ink: #e6f0ff;
      --accent: #7aa2ff;
      --accent-2: #7fffd4;
      --danger: #ff6b6b;
      --muted: #9aa3b2;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; display: grid; place-items: center; gap: 12px;
      background: radial-gradient(1000px 700px at 50% -20%, #1b2240, var(--bg));
      color: var(--ink); font: 500 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", sans-serif;
    }
    .wrap {
      width: min(920px, 96vw); padding: 16px; border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      box-shadow: 0 20px 60px rgba(0,0,0,0.45), inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 8px; }
    h1 { margin: 0; font-size: 18px; letter-spacing: 0.4px; color: var(--ink); opacity: 0.9; }
    .meta { display: flex; gap: 12px; align-items: center; color: var(--muted); }
    .btn {
      appearance: none; border: 0; padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 600; letter-spacing: 0.3px;
      color: #0b1020; background: var(--accent);
      box-shadow: 0 6px 20px rgba(122,162,255,0.4);
    }
    .btn:active { transform: translateY(1px); }

    canvas { width: 100%; height: auto; border-radius: 16px; display: block; background: linear-gradient(180deg, #0b1020, #060914); }

    .hud { display: grid; grid-template-columns: repeat(4, max-content); gap: 16px; align-items: center; margin: 8px 0 0; }
    .tag { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.06); color: var(--ink); font-weight: 600; }

    footer { margin-top: 8px; color: var(--muted); font-size: 13px; }
    kbd { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üü£ Orb Catcher ‚Äî tiny JS game</h1>
      <div class="meta">
        <button id="btnPause" class="btn" title="Pause/Resume (P)">Pause</button>
        <button id="btnReset" class="btn" title="Restart (R)">Restart</button>
      </div>
    </header>

    <canvas id="game" width="900" height="520"></canvas>

    <div class="hud">
      <div class="tag">Score: <span id="score">0</span></div>
      <div class="tag">Lives: <span id="lives">3</span></div>
      <div class="tag">Level: <span id="level">1</span></div>
      <div class="tag">Best: <span id="best">0</span></div>
    </div>

    <footer>
      Move with <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> or ‚¨ÖÔ∏è‚¨ÜÔ∏è‚¨áÔ∏è‚û°Ô∏è. Catch <span style="color:var(--accent-2)">glow orbs</span>, avoid <span style="color:var(--danger)">red bombs</span>.
      <strong>P</strong> to pause, <strong>R</strong> to restart. Touch/drag anywhere on mobile.
    </footer>
  </div>

  <script>
  // vibe coding mode: readable, tweakable, zero deps
  const canvas = document.getElementById('game');
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const ctx = canvas.getContext('2d');
  // scale canvas for crispness
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round((rect.width * 0.577) * dpr); // keep 16:9-ish
  }
  resize();
  addEventListener('resize', resize);

  // --- game state ---
  const state = {
    running: true,
    score: 0,
    best: Number(localStorage.getItem('orb_best') || 0),
    lives: 3,
    level: 1,
    time: 0,
    player: { x: 120, y: 120, r: 16 * dpr, speed: 260 },
    vx: 0, vy: 0,
    keys: new Set(),
    orbs: [], // {x,y,r,vy,type}
    lastSpawn: 0,
  };

  // UI bindings
  scoreEl = document.getElementById('score');
  livesEl = document.getElementById('lives');
  levelEl = document.getElementById('level');
  bestEl = document.getElementById('best');
  bestEl.textContent = state.best;
  btnPause = document.getElementById('btnPause');
  btnReset = document.getElementById('btnReset');
  btnPause.onclick = () => togglePause();
  btnReset.onclick = () => restart();

  // controls: keyboard
  addEventListener('keydown', (e) => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) {
      state.keys.add(e.key.toLowerCase());
    }
    if (e.key === 'p' || e.key === 'P') togglePause();
    if (e.key === 'r' || e.key === 'R') restart();
  });
  addEventListener('keyup', (e) => state.keys.delete(e.key.toLowerCase()));

  // controls: touch / drag to move
  let touchID = null;
  canvas.addEventListener('pointerdown', (e) => { touchID = e.pointerId; moveToPointer(e); });
  canvas.addEventListener('pointermove', (e) => { if (touchID === e.pointerId) moveToPointer(e); });
  addEventListener('pointerup', (e) => { if (touchID === e.pointerId) touchID = null; });
  function moveToPointer(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * dpr;
    const y = (e.clientY - rect.top) * dpr;
    state.player.x = x; state.player.y = y;
  }

  // helpers
  const rand = (a,b)=> Math.random()*(b-a)+a;
  const clamp = (x,a,b)=> Math.max(a, Math.min(b,x));

  function spawnOrb(now) {
    const w = canvas.width, h = canvas.height;
    const type = Math.random() < 0.8 ? 'good' : 'bad';
    const r = type === 'good' ? rand(10, 16) * dpr : rand(12,18) * dpr;
    const speedBase = 60 + state.level * 14;
    const vy = rand(speedBase, speedBase + 60);
    state.orbs.push({ x: rand(r, w - r), y: -r, r, vy, type, born: now });
  }

  function resetOrbs() { state.orbs.length = 0; state.lastSpawn = 0; }

  function restart() {
    state.score = 0; state.lives = 3; state.level = 1; state.time = 0; resetOrbs(); state.running = true; btnPause.textContent = 'Pause';
  }

  function togglePause() { state.running = !state.running; btnPause.textContent = state.running ? 'Pause' : 'Resume'; }

  // collision check (circle-circle)
  function hit(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y; return (dx*dx + dy*dy) <= (a.r + b.r) * (a.r + b.r);
  }

  // drawing helpers
  function glowCircle(x,y,r, color1, color2) {
    const g = ctx.createRadialGradient(x,y, r*0.1, x,y,r);
    g.addColorStop(0, color1);
    g.addColorStop(1, color2);
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  function drawText(txt, x, y, size = 16, align = 'left', color = '#e6f0ff') {
    ctx.font = `${Math.round(size*dpr)}px ui-sans-serif, system-ui, -apple-system`;
    ctx.textAlign = align; ctx.fillStyle = color; ctx.fillText(txt, x, y);
  }

  // main update/draw loop
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // backdrop stars
    for (let i=0;i<40;i++) {
      const x = (i*97 % canvas.width);
      const y = (i*197 + Math.sin((now*0.0006 + i))*40) % canvas.height;
      ctx.globalAlpha = 0.08 + (i%5)*0.02;
      glowCircle(x,y, 2*dpr, '#cfe5ff', 'transparent');
    }
    ctx.globalAlpha = 1;

    // spawn curve speeds up with level
    state.time += dt;
    const spawnEvery = Math.max(0.25, 0.9 - state.level*0.08);
    if (state.running && (now - state.lastSpawn) / 1000 > spawnEvery) {
      spawnOrb(now); state.lastSpawn = now;
    }

    // move player from keys
    if (state.running) {
      const p = state.player, s = state.player.speed * dpr;
      const dv = s * dt;
      if (state.keys.has('arrowleft') || state.keys.has('a')) p.x -= dv;
      if (state.keys.has('arrowright') || state.keys.has('d')) p.x += dv;
      if (state.keys.has('arrowup') || state.keys.has('w')) p.y -= dv;
      if (state.keys.has('arrowdown') || state.keys.has('s')) p.y += dv;
      p.x = clamp(p.x, p.r, canvas.width - p.r);
      p.y = clamp(p.y, p.r, canvas.height - p.r);
    }

    // update orbs
    for (const o of state.orbs) {
      if (state.running) o.y += o.vy * dt * dpr * 0.5; // normalize speed for DPR
      // draw orb
      if (o.type === 'good') glowCircle(o.x, o.y, o.r, '#b1ffea', 'rgba(127,255,212,0)');
      else glowCircle(o.x, o.y, o.r, '#ffb1b1', 'rgba(255,107,107,0)');
    }

    // remove offscreen
    state.orbs = state.orbs.filter(o => o.y - o.r < canvas.height + 10*dpr);

    // collisions
    if (state.running) {
      for (let i = state.orbs.length - 1; i >= 0; i--) {
        const o = state.orbs[i];
        if (hit(state.player, o)) {
          state.orbs.splice(i,1);
          if (o.type === 'good') {
            state.score += 1;
            if (state.score % 8 === 0) state.level += 1;
          } else {
            state.lives -= 1;
            if (state.lives <= 0) {
              state.running = false; btnPause.textContent = 'Resume';
              state.best = Math.max(state.best, state.score);
              localStorage.setItem('orb_best', String(state.best));
            }
          }
        }
      }
    }

    // draw player
    glowCircle(state.player.x, state.player.y, state.player.r, '#b8c7ff', 'rgba(122,162,255,0)');
    ctx.strokeStyle = 'rgba(122,162,255,0.6)';
    ctx.lineWidth = 2*dpr; ctx.beginPath(); ctx.arc(state.player.x, state.player.y, state.player.r*1.1, 0, Math.PI*2); ctx.stroke();

    // HUD overlay in-canvas
    drawText(`Score ${state.score}`, 16*dpr, 28*dpr);
    drawText(`Lives ${state.lives}`, 16*dpr, 50*dpr, 16);
    drawText(`Level ${state.level}`, canvas.width - 16*dpr, 28*dpr, 16, 'right');
    drawText(`Best ${state.best}`, canvas.width - 16*dpr, 50*dpr, 16, 'right');

    // Game over text
    if (!state.running && state.lives <= 0) {
      drawText('Game Over', canvas.width/2, canvas.height/2 - 20*dpr, 28, 'center');
      drawText('Press R to restart', canvas.width/2, canvas.height/2 + 10*dpr, 16, 'center', '#9aa3b2');
    }

    // update DOM HUD
    scoreEl.textContent = state.score;
    livesEl.textContent = state.lives;
    levelEl.textContent = state.level;
    bestEl.textContent = state.best;

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  </script>
</body>
</html>
